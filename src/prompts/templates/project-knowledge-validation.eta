# Project Knowledge Validation: Comprehensive Artifact Analysis & Evidence-Based Updates

You are tasked with validating and updating the existing project knowledge base through comprehensive analysis and evidence-based corrections (think harder). This process ensures the **knowledge foundation remains accurate, current, and trustworthy** for ongoing development work.

## Critical Mission

Validate all existing knowledge artifacts against the current codebase reality and make evidence-based updates to maintain knowledge base integrity. The accuracy and currency of this validation is crucial for reliable project development decisions.

## Current Project Knowledge Context

### Architecture & Codebase Knowledge
*Source: project://knowledge resource*

```
<%= projectContext.knowledge %>
```

### Current Decisions
*Source: project://decisions resource*

<% if (projectContext.decisions.length > 0) { %>
<% projectContext.decisions.forEach((decision) => { %>
**<%= decision.name %>**
- Description: <%= decision.description %>
- Tags: <%= decision.tags.join(', ') %>

<% }) %>
<% } else { %>
*No decisions currently defined.*
<% } %>

### Current Solutions
*Source: project://solutions resource*

<% if (projectContext.solutions.length > 0) { %>
<% projectContext.solutions.forEach((solution) => { %>
**Problem:** <%= solution.problem %>
- Solution: <%= solution.solution %>
- Tags: <%= solution.tags.join(', ') %>
<% if (solution.codeReferences && solution.codeReferences.length > 0) { %>
- Code References: <%= solution.codeReferences.join(', ') %>
<% } %>

<% }) %>
<% } else { %>
*No solutions currently defined.*
<% } %>

### Current Patterns
*Source: project://patterns resource*

<% if (projectContext.patterns.length > 0) { %>
<% projectContext.patterns.forEach((pattern) => { %>
**<%= pattern.name %>**
- Description: <%= pattern.description %>
- Tags: <%= pattern.tags.join(', ') %>
- Snippet File: <%= pattern.snippetFilename %>
<% if (pattern.codeReferences && pattern.codeReferences.length > 0) { %>
- Code References: <%= pattern.codeReferences.join(', ') %>
<% } %>

<% }) %>
<% } else { %>
*No patterns currently defined.*
<% } %>

## Three-Phase Validation Workflow

### Phase 1: Comprehensive Current State Analysis

Conduct **thorough analysis** of the current codebase state to identify changes since last knowledge update:

#### Codebase Evolution Assessment
- Examine current directory structure and organization changes
- Analyze dependency updates, new libraries, and technology stack evolution
- Identify architectural changes, new modules, and structural modifications
- Study code pattern evolution, new conventions, and implementation changes

#### Implementation Reality Check
- Trace current application entry points and bootstrap processes
- Map current system boundaries, APIs, and integration points
- Understand current data flow, state management, and architectural patterns
- Assess current configuration, deployment, and operational approaches

### Phase 2: Cross-Validation & Evidence Gathering

**Systematically compare** documented knowledge against codebase reality:

#### Architecture Validation
- **System Overview**: Verify documented purpose aligns with current functionality
- **Components & Modules**: Confirm documented components match current implementation
- **Technology Stack**: Validate documented technologies against actual dependencies
- **Architectural Patterns**: Check if documented patterns are still actively used
- **Data Flow**: Ensure documented data flow represents current implementation
- **Security & Performance**: Verify documented approaches match current practices

#### Codebase Documentation Validation  
- **Project Structure**: Compare documented structure with current directory organization
- **Key Files**: Verify documented important files still exist and serve described purposes
- **Dependencies**: Check documented libraries against current package.json/requirements
- **Build & Development**: Validate documented processes against current scripts and workflows
- **Coding Standards**: Ensure documented conventions match current code patterns

#### Knowledge Artifact Validation
- **Decisions**: Assess if documented decisions are still relevant and being followed
- **Solutions**: Verify documented solutions address current problems and are well-implemented
- **Patterns**: Check if documented patterns are actively used and have good code references
- **Evidence Collection**: For each artifact, gather specific file/line references that prove or disprove relevance

### Phase 3: Evidence-Based Knowledge Updates

**Make conservative, justified updates** using the `update_knowledge` tool:

#### Update Criteria (Conservative Approach)
- **Concrete Evidence Required**: Only update when you have specific proof of inaccuracy
- **Preserve by Default**: Keep existing content unless definitively wrong or outdated
- **Reference-Based Changes**: Provide specific file:line references for all claimed changes
- **No Assumptions**: Never remove content based on speculation or incomplete analysis

#### Update Execution
Use the `update_knowledge` tool with appropriate parameters:
- **Architecture Content**: Update `architectureContent` only if significant inaccuracies found
- **Codebase Content**: Update `codebaseContent` only if structural changes require documentation updates
- **Decisions**: Use decision operations (create/update/delete) with concrete justification
- **Solutions**: Update solution operations only when solutions are proven irrelevant or better examples found
- **Patterns**: Modify pattern operations only when patterns are demonstrably unused or better references available

#### Evidence Documentation
For every change made, document:
- **What was changed**: Specific content modified or removed
- **Why it was changed**: Concrete evidence from codebase analysis  
- **Supporting references**: File paths and line numbers that justify the change

## Update Knowledge Tool Usage Examples

### Updating Architecture/Codebase Documentation

**Complete Architecture Documentation Update:**
```json
{
  "architectureContent": "# System Architecture\n\n## Updated Overview\nBased on analysis of current codebase at src/main.ts:1-50, the system has evolved to use microservices architecture...\n\n[Complete new architecture content]"
}
```

**Complete Codebase Documentation Update:**
```json
{
  "codebaseContent": "# Codebase Structure\n\n## Project Organization\nAnalysis shows the project structure has changed significantly:\n\n- `/src/services/` - New microservices (evidence: directory exists with 5 service files)\n- `/src/api/` - REST endpoints (evidence: src/api/routes.ts:1-200)\n\n[Complete new codebase content]"
}
```

**Combined Architecture and Codebase Update:**
```json
{
  "architectureContent": "[Updated architecture content with evidence]",
  "codebaseContent": "[Updated codebase content with evidence]"
}
```

### Updating Structured Knowledge Artifacts

**Decision Operations:**
```json
{
  "decisions": {
    "create": [
      {
        "name": "use-microservices",
        "description": "Adopt microservices architecture for better scalability. Evidence: src/services/ directory with 5 independent services implemented.",
        "tags": ["architecture", "scalability", "services"]
      }
    ],
    "update": {
      "use-typescript": {
        "description": "Updated: TypeScript adoption is complete across all modules. Evidence: package.json shows @types/* dependencies, tsconfig.json exists, all .js files converted to .ts"
      }
    },
    "delete": ["use-jquery"]
  }
}
```

**Solution Operations:**
```json
{
  "solutions": {
    "create": [
      {
        "problem": "Database connection pooling for improved performance",
        "solution": "Implement connection pooling using pg-pool with configurable pool size and timeout settings",
        "tags": ["database", "performance", "postgresql"],
        "codeReferences": ["src/database/pool.ts:15-45", "src/config/database.ts:8-20"]
      }
    ],
    "update": {
      "error-handling": {
        "solution": "Updated to use structured error handling with custom error classes and centralized error middleware",
        "codeReferences": ["src/middleware/errorHandler.ts:1-50", "src/utils/errors.ts:10-80"]
      }
    },
    "delete": ["old-logging-solution"]
  }
}
```

**Pattern Operations:**
```json
{
  "patterns": {
    "create": [
      {
        "name": "service-factory",
        "description": "Factory pattern for creating service instances with dependency injection",
        "tags": ["factory", "dependency-injection", "services"],
        "snippetFilename": "service-factory.ts",
        "snippetContent": "export class ServiceFactory {\n  static create<T>(ServiceClass: new (...args: any[]) => T, dependencies: any[]): T {\n    return new ServiceClass(...dependencies);\n  }\n}",
        "codeReferences": ["src/services/UserService.ts:5-15", "src/services/ProductService.ts:8-18"]
      }
    ],
    "update": {
      "api-response": {
        "description": "Updated to include standardized error responses with error codes",
        "snippetContent": "interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: { code: string; message: string; };\n}",
        "codeReferences": ["src/api/responses.ts:1-20", "src/controllers/BaseController.ts:25-40"]
      }
    },
    "delete": ["old-validation-pattern"]
  }
}
```

**Combined Operations Example:**
```json
{
  "architectureContent": "[Updated architecture with microservices documentation]",
  "decisions": {
    "create": [
      {
        "name": "microservices-adoption",
        "description": "Migrate to microservices architecture. Evidence: src/services/ contains 5 independent services with separate databases",
        "tags": ["architecture", "microservices"]
      }
    ]
  },
  "solutions": {
    "create": [
      {
        "problem": "Service communication in microservices",
        "solution": "Use message queues with Redis for async communication between services",
        "tags": ["microservices", "messaging", "redis"],
        "codeReferences": ["src/messaging/queue.ts:1-100", "src/services/*/messaging.ts"]
      }
    ]
  }
}
```

### Evidence-Based Update Guidelines

**Required Evidence for Updates:**
- **File References**: Include specific `file:line` or `file:startLine-endLine` references
- **Concrete Proof**: Point to actual code, configuration, or structure changes
- **Verification**: Ensure referenced files and lines actually exist and support claims

**Conservative Approach:**
- Only update when you have definitive proof of inaccuracy
- Preserve existing content unless clearly wrong or outdated
- Document reasoning with specific evidence for every change
- When in doubt, keep existing content rather than remove it

## Quality & Integrity Requirements

### Evidence Standards
- **Specific References**: All claims must include file:line evidence
- **Verifiable Facts**: Every statement must be provable against actual code
- **Conservative Bias**: Prefer keeping questionable content over removing it
- **Documentation Trail**: Clearly explain reasoning for all modifications

### Knowledge Base Integrity
- **Accuracy**: Ensure all content reflects current codebase reality
- **Completeness**: Maintain comprehensive coverage without arbitrary gaps
- **Consistency**: Keep all artifacts aligned and cross-referenced properly
- **Reliability**: Maintain knowledge base as trustworthy development resource

## Success Criteria

Your validation is successful when:
1. **Thorough Analysis Complete**: Current codebase state is comprehensively understood
2. **Evidence-Based Comparison**: All knowledge claims validated against actual implementation  
3. **Justified Updates Made**: Only necessary changes made with concrete supporting evidence
4. **Knowledge Base Updated**: All updates persisted using `update_knowledge` tool with proper justification
5. **Integrity Maintained**: Knowledge base remains reliable foundation for future development

## Critical Guidelines

**NEVER remove or modify content without specific evidence of inaccuracy**
**ALWAYS provide file:line references for claimed changes**
**PRESERVE historical decisions and patterns unless proven irrelevant**
**MAINTAIN comprehensive documentation coverage**

**Remember**: The knowledge base is a critical project asset. Future developers and AI agents depend on its accuracy. Changes must be evidence-based and justified to maintain trust and reliability.