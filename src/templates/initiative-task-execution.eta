# Execute Tasks for Initiative

You are executing specific tasks within the following initiative:

<%~ include('partials/initiative-data', { initiative: it.context.initiative }) %>

<%~ include('partials/project-context', it) %>

<%~ include('partials/memory-cards', { memoryCards: it.context.initiativeMemoryCards }) %>

## Current Initiative Tasks

<%= it.generateTasksMarkdownReport(it.context.tasks) %>

## Tasks to Execute

You are specifically assigned to execute the following tasks:

<% it.selectedTasks.forEach(function(task, index) { %>### Task <%= index + 1 %>: <%= task.name %> (ID: <%= task.id %>)
<% if (task.effort) { %>**Effort:** <%= task.effort %>
<% } %>**Phase:** <%= task.phase %>
**Order:** <%= task.order %>
<% if (task.predecessors.length > 0) { %>**Prerequisites:** <%= task.predecessors.join(', ') %> (all completed or included in this execution batch)
<% } else { %>**Prerequisites:** None
<% } %>
<%= task.description %>
<% }); %>

## Execution Guidelines

### Work Context
1. Use git to get the latest commits in the initiative branch.
2. Analyze the task and collect any relevant information.
3. Use the `memory_cards_search` tool to find relevant memory cards.

### Planning
1. Always start with detailed planning and analysis.
2. Validate your plan before starting work.

### Work Approach
1. **Use Available Knowledge**: Leverage the project memory shown above
2. **Follow Architecture**: Respect existing codebase patterns and constraints
3. **Maintain Quality**: Follow established coding standards and practices
4. **Test Thoroughly**: Ensure all changes work correctly and don't break existing functionality

### âœ¨ Capturing High-Value Knowledge (Memory Cards)

Your goal is to capture **high-value, reusable knowledge**, not to create a detailed log of your actions. Before creating a memory card, ask yourself: **"Ð‘ÑƒÐ´ÐµÑ‚ Ð»Ð¸ ÑÑ‚Ð° Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¿Ð¾Ð»ÐµÐ·Ð½Ð° Ð´Ñ€ÑƒÐ³Ð¾Ð¼Ñƒ Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÑƒ Ñ‡ÐµÑ€ÐµÐ· Ð¼ÐµÑÑÑ†?"**

#### The Quality Filter: What to Capture

Only create memory cards for insights that meet these criteria:

**ðŸ§  1. Non-Obvious Decisions**
Capture decisions that have long-term consequences, required trade-offs, or deviate from established standards.
* **WHEN?** You chose one technical approach over several alternatives.
* **WHAT?** Document the **decision**, the **alternatives considered**, and crucially, the **rationale (why)**.
* **TAGS:** `decision`, `architecture`, `trade-off`

> **Example:**
> - **Title:** Choice of 'Vectra' for Vector Search
> - **Content:**
>   `**Decision:**` Adopted `Vectra` for local vector search.
>   `**Rationale:**` It's a lightweight, file-based solution without external dependencies, perfect for a self-contained MCP server. Alternatives like FAISS were considered too complex to set up.
>   `**Trade-off:**` Sacrificed potential performance of larger systems for simplicity and portability.

**ðŸ’¡ 2. Reusable Solutions to Non-Trivial Problems**
Document solutions to unexpected, complex, or tricky problems that another developer might encounter.
* **WHEN?** You spent significant time debugging an issue or found a clever workaround.
* **WHAT?** Describe the **problem context**, the **solution implemented**, and any key code snippets.
* **TAGS:** `solution`, `bugfix`, `workaround`, `[technology-name]`

> **Example:**
> - **Title:** Handling Circular Dependencies in Task Predecessors
> - **Content:**
>   `**Problem:**` The `processTaskOperations` function could create a circular dependency (e.g., t001 -> t002 -> t001), causing infinite loops.
>   `**Solution:**` Implemented a depth-first search (DFS) algorithm (`detectCircularDependencies`) that traverses the task graph, keeping track of visited nodes in the current recursion stack to detect cycles before saving.

**ðŸ“ 3. Emergent & Reusable Patterns**
Capture design or code patterns that you successfully applied and believe should be reused throughout the project.
* **WHEN?** You refactored code to create a more generic, reusable component or function.
* **WHAT?** Provide a concise **name for the pattern**, a **description of its use case**, and a short, canonical **code example**.
* **TAGS:** `pattern`, `refactoring`, `best-practice`

> **Example:**
> - **Title:** Completable Zod Schema for Dynamic Autocomplete
> - **Content:**
>   `**Pattern:**` Created a factory function `createCompletableInitiativeId` that wraps a Zod schema with a completion function for dynamic suggestions in MCP prompts.
>   `**Use Case:**` For any prompt argument requiring an existing initiative ID, this pattern provides validation and IDE-like autocomplete.

#### What to AVOID (Low-Value Cards) ðŸš«

**Do not** create memory cards for:
* **Obvious steps:** "Started the server", "Installed dependencies".
* **Routine debugging:** "Fixed a typo in a variable name".
* **Verbose logs:** A chronological diary of every command you ran.
* **Large, unfocused documents:** A single card should represent a single, atomic piece of knowledge. **Keep it concise!**

### Task Completion Process

For each task you complete:

1. **Execute the work** following the task description and acceptance criteria
2. **Test your implementation** to ensure it works correctly
3. **Document any knowledge gained** (decisions, solutions, patterns etc.)
4. **Update task status** using the initiative_update tool

### Status Updates

 - After completing tasks, update their status using the `initiative_update` tool:

```json
{
	"id": "<%= it.context.initiative.id %>",
	"tasks": {
		"update": {
			"<task-id>": {"status": "done"}
		}
	}
}
```

 - Initiative memory cards create/update/remove using the `memory_card_add_or_update`/`memory_card_remove` tool

### Code Quality Requirements

- **Follow existing patterns** in the codebase
- **Maintain consistency** with established conventions
- **Add appropriate tests** if test framework exists
- **Update documentation** if changes affect public APIs
- **Run linting/formatting** tools before completion

## Ready to Execute

You now have all the context needed to execute these tasks effectively. Begin with the first task and work systematically through each one, tracking your decisions and solutions as you progress.

Remember to update task statuses and capture knowledge using the initiative_update tool after completing each task.

<% if (it.comments?.length > 0 ) {%>
# User comments
<%= it.comments %>
<%}%>